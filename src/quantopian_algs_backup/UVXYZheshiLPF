"""

"""
import talib
import numpy as np
from scipy import stats
import pandas as pd

def initialize(context):
    """
    Called once at the start of the algorithm.
    """
    # Record tracking variables at the end of each day.
    schedule_function(at_market_close, date_rules.every_day(), time_rules.market_close())
    schedule_function(func=before_market_close,
                      date_rule=date_rules.every_day(),
                      time_rule=time_rules.market_close(minutes=1),
                      half_days=True)
    context.running_status = 'running'
    context.symbols = {}
    # at this time, target_stock is AAPL
    context.symbols["target_stock"] = sid(24)
    context.symbols["uvxy"] = sid(41969)
    # sid(19725)  # NVDA
    # sid(5061) # MSFT
    # sid(46632) # GOOGL
    # sid(16841) # AMZN

    # input parameters
    context.span = 20
    context.tolerance = 0.05
    context.inday_fuse = 0.015

    log.info("target_stock      : {}".format(context.symbols["target_stock"].symbol))
    log.info("moving max span   : {}".format(context.span ))
    log.info("tolerance         : {}".format(context.tolerance))
    log.info("context.inday_fuse: {}".format(context.inday_fuse))
    log.info("starting_cash     : {}".format(context.portfolio.starting_cash))

    context.hist_data = {}
    # strategy needed
    context.cnt_of_resuming = 0
    context.inday_max = 0
    context.stop_gainloss = 0.0
    context.reset_stop_gainloss = False
    context.running_status = 'closed'

    context.last_stop_time = None
    context.last_stop_price = 0

    # plot needed
    context.first_time_before_trading = True
    context.init_target_close = -1

def before_market_close(context, data):
    """
    Called 1-3 minutes before market close,
    """
    # following is not good.
    # order_target_percent(context.symbols["target_stock"], 0.0)
    pass

def before_trading_start(context, data):
    """
    Called every day before market open.
    """
    context.cnt_of_resuming = 0
    context.inday_max = 0

    # following context.init_target_close is used for plotting relative return
    if context.first_time_before_trading:
        context.first_time_before_trading = False
        context.init_target_close = data.history(context.symbols["target_stock"], "close", 1, '1d')[0]
        log.info("init_target_close {}".format(context.init_target_close))
        context.hist_data['uvxy_closes'] = data.history(context.symbols["uvxy"], fields='close', bar_count=120, frequency='1d')
        context.hist_data['target_closes'] = data.history(context.symbols["target_stock"], 'close', 1170, '1m')
        log.info("len(context.hist_data['target_closes']) : {}".format(len(context.hist_data['target_closes'])))
        log.info(context.hist_data['target_closes'].head(10))

        # TODO 3-min ROCP, 5-min ROCP
        tgt_closes = context.hist_data['target_closes']
        symbol_name = context.symbols["target_stock"].symbol
        tgt_closes.name = symbol_name

    context.hist_data['rocp_5_ser'] = get_rocp(context.hist_data['target_closes'], 5, window_not_cross='day')
    log.info('len(tgt_closes): {}, len(rocp_5_ser): {}'.format(
            len(context.hist_data['target_closes']),
            len(context.hist_data['rocp_5_ser'])))


def at_market_close(context, data):
    """
    Plot variables at the end of each day, ATTENTION called before last handle_data of one trading day
    """
    target_stock = context.symbols["target_stock"]
    to_be_recorded_map = {
        target_stock.symbol: data.current(target_stock, 'price') / context.init_target_close,
        'port_value': context.portfolio.portfolio_value / context.portfolio.starting_cash
    }
    record(**to_be_recorded_map)

    # add cur uvxy closes to uvxy_closes
    cur_uvxy_close = data.history(assets=context.symbols['uvxy'], fields='close', bar_count=1, frequency='1d')
    context.hist_data['uvxy_closes'] = context.hist_data['uvxy_closes'].append(cur_uvxy_close)
    context.hist_data['uvxy_closes'].drop(context.hist_data['uvxy_closes'].index[0], inplace=True)

    # TODO(remove ) first trading day minutes bars
    tgt_closes = context.hist_data['target_closes']
    min_date_str = tgt_closes.index.min().strftime('%Y-%m-%d')
    log.info("going to drop data recorded in min_date_str: {}".format(min_date_str))
    # remove records of earliest trading day
    tgt_closes.drop(tgt_closes.loc[min_date_str].index, inplace=True)


def handle_data(context, data):
    """
    Called every minute.
    """
    # only handle regular trading time
    # log.info(get_datetime('US/Eastern'))

    target_stock = context.symbols["target_stock"]
    cur_uvxy = data.history(context.symbols['uvxy'], 'close', 1, '1d')   # cur_uvxy is len-1 pd.Series
    cur_uvxy_scalar = cur_uvxy.iloc[0]
    cur_price = data.history(target_stock, 'close', 1, '1m')
    cur_price_scalar = cur_price.iloc[0]
    context.inday_max = max(context.inday_max, cur_price.iloc[0])
    context.hist_data['target_closes'] = context.hist_data['target_closes'].append(cur_price)

    recent_uvxy_closes = context.hist_data['uvxy_closes'].iloc[-context.span + 1:]
    recent_uvxy_closes = pd.concat([recent_uvxy_closes, cur_uvxy])
    uvxy_hi, uvxy_sma, uvxy_lo = talib.BBANDS(recent_uvxy_closes, timeperiod=context.span)
    uvxy_hi, uvxy_sma, uvxy_lo = uvxy_hi[-1], uvxy_sma[-1], uvxy_lo[-1]
    two_sigma_uvxy = uvxy_hi - uvxy_sma
    # log.info("current uvxy : {}, bbpos: {}".format(cur_uvxy_scalar, (cur_uvxy_scalar - uvxy_sma) / two_sigma_uvxy))
    # log.info("len(context.hist_data['target_closes']) : {}".format(len(context.hist_data['target_closes'])))
    max_date_str = context.hist_data['target_closes'].index.max().strftime('%Y-%m-%d')
    today_closes = context.hist_data['target_closes'].loc[max_date_str]
    # log.info(len(today_closes))
    five_min_ago_price = today_closes.iloc[-6 if len(today_closes) > 5 else 0]
    cur_rocp = (cur_price_scalar - five_min_ago_price) / five_min_ago_price
    score = stats.percentileofscore(context.hist_data['rocp_5_ser'], cur_rocp)

    log.info("cur_rocp: {0:.5f}, score: {1:.2f}".format(cur_rocp, score))

    # inday_loss_control = (1 - context.inday_fuse) * context.trading_day_open
    # loss_control = max((1 - context.tolerance) * context.moving_max, inday_loss_control)

    # if cur_price < loss_control:
    #     order_target_percent(target_stock, 0.0)
    #     context.running_status = 'closed'
    # elif cur_price > loss_control * (1 + 0.001 * context.cnt_of_resuming):
    #     order_target_percent(target_stock, 1.0)
    #     if context.running_status != 'running':
    #         # record status change
    #         context.cnt_of_resuming += 1
    #     context.running_status = 'running'

# ROCP rate of change percentage
def get_rocp(in_ser, window_size, name=None, window_not_cross=None):
    """
    ROCP - Rate of change Percentage: (price-prevPrice)/prevPrice
    """
    if not isinstance(in_ser, pd.Series):
        raise TypeError("in_ser should be pandas Series")
    if window_not_cross not in ('month', 'day'):
        raise ValueError("{} is not a valid property of a pd Timestamp", window_not_cross)
    # if window_size <= 0:
    #     raise ValueError("window size should be larger than 0")
    rocp_series = in_ser.diff(window_size)
    rocp_series = rocp_series / in_ser.shift(window_size)
    rocp_series.name = '{}_ROCP_{}'.format(in_ser.name, window_size) if not name else name
    if not window_not_cross:
        return rocp_series

    rocp_series = rocp_series.dropna()
    rocp_series_idx_ser = pd.Series(np.array(range(len(rocp_series))), index=rocp_series.index, name='INDEX')

    if window_not_cross == 'month':
        selected_labels = rocp_series_idx_ser[
            lambda idx: in_ser.index[idx].month == rocp_series.index[idx].month].index
    elif window_not_cross == 'day':
        selected_labels = rocp_series_idx_ser[
            lambda idx: in_ser.index[idx].day == rocp_series.index[idx].day].index
    else:
        raise Exception('impossible to reach')
    return rocp_series.loc[selected_labels]